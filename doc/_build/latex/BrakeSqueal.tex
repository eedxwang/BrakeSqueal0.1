% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{BrakeSqueal Documentation}
\date{August 06, 2014}
\release{0.1}
\author{Ali H. Kadar}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{brake}
\label{index:brake}\label{index:welcome-to-brakesqueal-s-documentation}

\section{\_\_init\_\_}
\label{index:init}\label{index:module-__init__}\index{\_\_init\_\_ (module)}

\chapter{initialize}
\label{index:initialize}

\section{logger}
\label{index:logger}\label{index:module-logger}\index{logger (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{} return\PYGZus{}info\PYGZus{}logger:
  
  Creates and returns a python logger object for information logging
  
\PYGZhy{} return\PYGZus{}time\PYGZus{}logger:
  
  Creates and returns a python logger object for time logging
\end{Verbatim}
\index{return\_info\_logger() (in module logger)}

\begin{fulllineitems}
\phantomsection\label{index:logger.return_info_logger}\pysiglinewithargsret{\code{logger.}\bfcode{return\_info\_logger}}{\emph{obj}}{}
INPUT:
\begin{itemize}
\item {} 
\code{obj} -- object of the class \code{BrakeClass}

\end{itemize}

OUTPUT:
\begin{itemize}
\item {} 
\code{logger\_i} -- python logger object for information logging

\end{itemize}

\end{fulllineitems}

\index{return\_time\_logger() (in module logger)}

\begin{fulllineitems}
\phantomsection\label{index:logger.return_time_logger}\pysiglinewithargsret{\code{logger.}\bfcode{return\_time\_logger}}{\emph{obj}}{}
INPUT:
\begin{itemize}
\item {} 
\code{obj} -- object of the class \code{BrakeClass}

\end{itemize}

OUTPUT:
\begin{itemize}
\item {} 
\code{logger\_t} -- python logger object for time logging

\end{itemize}

\end{fulllineitems}



\section{load}
\label{index:load}\label{index:module-load}\index{load (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{} load\PYGZus{}matrices:

  This function loads the sparse data matrices in .mat format and adds them to a python list
\end{Verbatim}
\index{load\_matrices() (in module load)}

\begin{fulllineitems}
\phantomsection\label{index:load.load_matrices}\pysiglinewithargsret{\code{load.}\bfcode{load\_matrices}}{\emph{obj}}{}
INPUT:
\begin{itemize}
\item {} 
\code{obj} -- object of the class BrakeClass

\end{itemize}

OUTPUT:
\begin{itemize}
\item {} 
\code{sparse\_list} -- a python list of matrices in Compressed Sparse Column format 
of type `\textless{}type `numpy.float64'\textgreater{}'

\end{itemize}

The \code{sparse\_list} is obtained by loading the vaious .mat files present in the
\code{data\_file\_list} attribute of the \code{BrakeClass} and then appending them into
a python list \code{sparse\_list}

\end{fulllineitems}



\section{assemble}
\label{index:assemble}\label{index:module-assemble}\index{assemble (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{} create\PYGZus{}MCK:

  Assembles the various component matrices together(for the given angular frequency
  {}`{}`omega{}`{}`) to form the mass(M), damping(C) and stiffness matrix(K).
\end{Verbatim}
\index{create\_MCK() (in module assemble)}

\begin{fulllineitems}
\phantomsection\label{index:assemble.create_MCK}\pysiglinewithargsret{\code{assemble.}\bfcode{create\_MCK}}{\emph{obj}, \emph{sparse\_list}, \emph{omega}}{}
INPUT:
\begin{itemize}
\item {} 
\code{obj} -- object of the class \code{BrakeClass}

\item {} 
\code{sparse\_list} -- a python list of matrices in Compressed Sparse Column format 
of type `\textless{}type `numpy.float64'\textgreater{}'

\item {} 
\code{omega} -- angular frequency

\end{itemize}

OUTPUT:
\begin{itemize}
\item {} 
\code{M} -- Mass Matrix

\item {} 
\code{C} -- Damping Matrix

\item {} 
\code{K} -- Stiffness Matrix

\end{itemize}

The \code{M} , \code{C} , \code{K} are assembled as follows:
\begin{itemize}
\item {} 
\code{M} = m

\item {} 
\code{C} = c1+c2*(omega/omegaRef)+c3*(omegaRef/omega)

\item {} 
\code{K} = k1+k2+k3*math.pow((omega/omegaRef),2)

\end{itemize}

\end{fulllineitems}



\section{shift}
\label{index:shift}\label{index:module-shift}\index{shift (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{} shift\PYGZus{}matrices:

  Transform the qevp using shift and invert spectral transformations.
\end{Verbatim}
\index{shift\_matrices() (in module shift)}

\begin{fulllineitems}
\phantomsection\label{index:shift.shift_matrices}\pysiglinewithargsret{\code{shift.}\bfcode{shift\_matrices}}{\emph{obj}, \emph{m}, \emph{c}, \emph{k}, \emph{tau}}{}
INPUT:
\begin{itemize}
\item {} 
\code{obj} -- object of the class \code{BrakeClass}

\item {} 
\code{m} -- Mass Matrix

\item {} 
\code{c} -- Damping Matrix

\item {} 
\code{k} -- Stiffness Matrix

\item {} 
\code{tau} -- shift

\end{itemize}

OUTPUT:
\begin{itemize}
\item {} 
\code{M} -- Shifted Mass Matrix

\item {} 
\code{C} -- Shifted Damping Matrix

\item {} 
\code{K} -- Shifted Stiffness Matrix

\end{itemize}

The \code{M} , \code{C} , \code{K} are obtained as follows:
\begin{itemize}
\item {} 
\code{M} = m

\item {} 
\code{C} = 2 * tau * m + c

\item {} 
\code{K} = tau\_squared * m + tau * c + k

\end{itemize}

\end{fulllineitems}



\section{scale}
\label{index:scale}\label{index:module-scale}\index{scale (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{} scale\PYGZus{}matrices:

  Scales the M, C, K matrices using 2\PYGZhy{}scalers before linearization.
\end{Verbatim}
\index{scale\_matrices() (in module scale)}

\begin{fulllineitems}
\phantomsection\label{index:scale.scale_matrices}\pysiglinewithargsret{\code{scale.}\bfcode{scale\_matrices}}{\emph{obj}, \emph{m}, \emph{c}, \emph{k}}{}
INPUT:
\begin{itemize}
\item {} 
\code{obj} -- object of the class \code{BrakeClass}

\item {} 
\code{m} -- Mass Matrix

\item {} 
\code{c} -- Damping Matrix

\item {} 
\code{k} -- Stiffness Matrix

\end{itemize}

OUTPUT:
\begin{itemize}
\item {} 
\code{M} -- Scaled Mass Matrix

\item {} 
\code{C} -- Scaled Damping Matrix

\item {} 
\code{K} -- Scaled Stiffness Matrix

\item {} 
\code{gamma} -- scaling parameter

\item {} 
\code{delta} -- scaling parameter

\end{itemize}

The \code{M} , \code{C} , \code{K}, \code{gamma}, \code{delta}  are obtained as follows:
\begin{itemize}
\item {} 
\code{M} = gamma*gamma*delta*m;

\item {} 
\code{C} = gamma*delta*c;

\item {} 
\code{K} = delta*k;

\item {} 
\code{gamma} = math.sqrt(k\_norm/m\_norm);

\item {} 
\code{delta} = 2/(k\_norm+c\_norm*gamma);

\end{itemize}

\end{fulllineitems}



\section{diagscale}
\label{index:module-diagscale}\label{index:diagscale}\index{diagscale (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{} normalize\PYGZus{}cols:

  Returns a diagonal matrix D such that every column of A*D has eucledian norm = 1. 
  
\PYGZhy{} norm\PYGZus{}rc:

  Returns diagonal matrix DL and DR such that every row and every column of DL*Y*DR
  has euclidean norm \PYGZti{} 1.

\PYGZhy{} diag\PYGZus{}scale\PYGZus{}matrices:

  Diagonally scales the shifted scalar\PYGZhy{}scaled matrices using DL, DR to improve the
  condition number.
\end{Verbatim}
\index{diag\_scale\_matrices() (in module diagscale)}

\begin{fulllineitems}
\phantomsection\label{index:diagscale.diag_scale_matrices}\pysiglinewithargsret{\code{diagscale.}\bfcode{diag\_scale\_matrices}}{\emph{obj}, \emph{M}, \emph{C}, \emph{K}}{}
INPUT:
\begin{itemize}
\item {} 
\code{obj} -- object of the class \code{BrakeClass}

\item {} 
\code{M} -- Mass Matrix

\item {} 
\code{C} -- Damping Matrix

\item {} 
\code{K} -- Stiffness Matrix

\end{itemize}

OUTPUT:
\begin{itemize}
\item {} 
\code{M} -- Diagonally Scaled Mass Matrix

\item {} 
\code{C} -- Diagonally Scaled Damping Matrix

\item {} 
\code{K} -- Diagonally Scaled Stiffness Matrix

\item {} 
\code{DR} -- Matrix that normalize the columns

\end{itemize}

The \code{M} , \code{C} , \code{K}, \code{DR}  are obtained as follows:
\begin{itemize}
\item {} 
\code{M} = \code{DL * M * DR}

\item {} 
\code{C} = \code{DL * C * DR}

\item {} 
\code{K} = \code{DL * K * DR}

\end{itemize}

\end{fulllineitems}

\index{norm\_rc() (in module diagscale)}

\begin{fulllineitems}
\phantomsection\label{index:diagscale.norm_rc}\pysiglinewithargsret{\code{diagscale.}\bfcode{norm\_rc}}{\emph{Y}}{}
INPUT:
\begin{itemize}
\item {} 
\code{Y} -- matrix that needs to be normalized across both columns and rows

\end{itemize}

OUTPUT:
\begin{itemize}
\item {} 
\code{DL} -- \code{DL} = ..... \code{Drow3} * \code{Drow2} * \code{Drow1} * I

\item {} 
\code{DR} -- \code{DR} = \code{I} * \code{Dcol1} * \code{Dcol2} * \code{Dcol3}......

\end{itemize}

The \code{DL} and \code{DR} are obtained as a converging sequence :
\begin{itemize}
\item {} 
set \code{Dcol = normalize columns(Y)}

\item {} 
set \code{DR = DR * Dcol}

\item {} 
set \code{Y = Y * Dcol}

\item {} 
set \code{Drow = normalize rows(Y) = normalize columns(Y.T)}

\item {} 
set \code{DL = Drow * DL}

\item {} 
set \code{Y = Drow * Y}

\item {} 
when \code{Dcol} and \code{Drow} are sufficiently close to \code{I} or max no of iterations reached
STOP and return, else continue with step 1.

\end{itemize}

\end{fulllineitems}

\index{normalize\_cols() (in module diagscale)}

\begin{fulllineitems}
\phantomsection\label{index:diagscale.normalize_cols}\pysiglinewithargsret{\code{diagscale.}\bfcode{normalize\_cols}}{\emph{A}}{}
INPUT:
\begin{itemize}
\item {} 
\code{A} -- matrix that needs to be normalized(columnwise)

\end{itemize}

OUTPUT:
\begin{itemize}
\item {} 
\code{D} -- diagonal matrix such that every column of \code{A*D} has eucledian norm = 1.

\end{itemize}

\code{D} is obtained as follows:
\begin{itemize}
\item {} 
square the elements of A and sum each column

\item {} 
set the diagonal elemnts of D as the inverse square root of the column sums

\end{itemize}

\end{fulllineitems}



\section{unlinearize}
\label{index:module-unlinearize}\label{index:unlinearize}\index{unlinearize (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{} unlinearize\PYGZus{}matrices:
  
  To obtain the eigenvectors prior linearization of the QEVP from the 
  resulting eigenvectors (after classical companion linearization of the QEVP
  to obtain the generalized eigenvalue propblem).
\end{Verbatim}
\index{unlinearize\_matrices() (in module unlinearize)}

\begin{fulllineitems}
\phantomsection\label{index:unlinearize.unlinearize_matrices}\pysiglinewithargsret{\code{unlinearize.}\bfcode{unlinearize\_matrices}}{\emph{evec}}{}
INPUT:
\begin{itemize}
\item {} 
\code{evec} -- eigenvectors of the generalized eigenvalue propblem

\end{itemize}

OUTPUT:
\begin{itemize}
\item {} 
\code{evec\_prior} -- eigenvectors prior linearization of the QEVP

\end{itemize}

The \code{evec\_prior} are obtained as follows:
\begin{itemize}
\item {} 
check for every vector \code{i} of the GEVP(\code{evec}) (consider MATLAB convention)

\item {} 
if \code{norm(evec{[}1:n,i{]}) \textgreater{} norm(evec{[}n+1:2*n,i{]}) set evec\_prior{[}:,i{]} = evec{[}1:n,i{]}}

\item {} 
else \code{set evec\_prior{[}:,i{]} = evec{[}n+1:2*n,i{]}}

\end{itemize}

\end{fulllineitems}



\chapter{solve}
\label{index:solve}

\section{projection}
\label{index:module-projection}\label{index:projection}\index{projection (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{} obtain\PYGZus{}projection\PYGZus{}matrix:

 This function forms the Projection Matrix by solving the quadratic eigenvalue problem 
 for each base angular frequency.
\end{Verbatim}
\index{obtain\_projection\_matrix() (in module projection)}

\begin{fulllineitems}
\phantomsection\label{index:projection.obtain_projection_matrix}\pysiglinewithargsret{\code{projection.}\bfcode{obtain\_projection\_matrix}}{\emph{obj}}{}
INPUT:
\begin{itemize}
\item {} 
\code{obj} -- object of the class \code{BrakeClass}

\end{itemize}

OUTPUT:
\begin{itemize}
\item {} 
\code{Q} -- projection matrix

\end{itemize}

The projection matrix is obtained as follows:
\begin{itemize}
\item {} 
Obtain the measurment matrix \code{X = {[}X\_real X\_imag{]}}, with \code{X\_real} as a list of 
real parts of eigenvectors and \code{X\_imag} as a list of imaginary parts of 
eigenvectors, corresponding to each base angular frequency in \code{omega\_basis}.

\item {} 
Compute the thin svd of the measurment matrix. \code{X = U * s * V}

\item {} 
Set \code{Q = truncated(U)}, where the truncation is done to take only the significant 
singular values(based on a certain tolerance) into account

\end{itemize}

\end{fulllineitems}



\section{qevp}
\label{index:qevp}\label{index:module-qevp}\index{qevp (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZhy{} brake\PYGZus{}squeal\PYGZus{}qevp:

  For a particuar base angular frequency this function assembles the eigenvalues
  and eigenvectors for different shift points in the target region.
  
\PYGZhy{}  Obtain\PYGZus{}eigs:
  
  For a particuar base angular frequency and for a particular shift point this 
  function evaluates the eigenvalues and eigenvectors
\end{Verbatim}
\index{Obtain\_eigs() (in module qevp)}

\begin{fulllineitems}
\phantomsection\label{index:qevp.Obtain_eigs}\pysiglinewithargsret{\code{qevp.}\bfcode{Obtain\_eigs}}{\emph{obj}, \emph{freq\_i}, \emph{qevp\_j}, \emph{omega}, \emph{next\_shift}}{}
INPUT:
\begin{itemize}
\item {} 
\code{obj} -- object of the class \code{BrakeClass}

\item {} 
\code{freq\_i} -- the index of the base angular freq

\item {} 
\code{qevp\_j} -- the index of the shift point

\item {} 
\code{omega} -- ith base angular freq

\item {} 
\code{next\_shift} -- jth shift point in the target region

\end{itemize}

OUTPUT:
\begin{itemize}
\item {} 
\code{la} -- eigenvalues

\item {} 
\code{evec} -- eigenvectors

\end{itemize}

The \code{la} and \code{evec} are obtained as follows:
\begin{itemize}
\item {} 
load the various component matrices

\item {} 
assemble the various component matrices together(for the given angular frequency
\code{omega}) to form the mass(M), damping(C) and stiffness matrix(K).

\item {} 
because we are interested in inner eigenvalues around certain shift points
\code{next\_shift}, so we transform the qevp using shift and invert spectral
transformations.

\item {} 
\end{itemize}

\end{fulllineitems}

\index{brake\_squeal\_qevp() (in module qevp)}

\begin{fulllineitems}
\phantomsection\label{index:qevp.brake_squeal_qevp}\pysiglinewithargsret{\code{qevp.}\bfcode{brake\_squeal\_qevp}}{\emph{obj}, \emph{freq\_i}, \emph{omega}}{}
INPUT:
\begin{itemize}
\item {} 
\code{obj} -- object of the class \code{BrakeClass}

\item {} 
\code{freq\_i} -- the index of the base angular freq in

\item {} 
\code{omega} -- ith base angular freq

\end{itemize}

OUTPUT:
\begin{itemize}
\item {} 
\code{assembled\_la} -- assembled eigenvalues

\item {} 
\code{assembled\_evec} -- assembled eigenvectors

\end{itemize}

The \code{assembled\_la} and \code{assembled\_evec} are obtained as follows:
\begin{itemize}
\item {} 
calculate the next shift point in the target region

\item {} 
obtain eigenvalues and eigenvectors for that particular shift point

\item {} 
add the eigenvalues and eigenvectors to \code{assembled\_la} and \code{assembled\_evec} respectively

\item {} 
check if the required area fraction of the target region has been covered. If \code{yes} return
\code{assembled\_la} and \code{assembled\_evec} else calculate the next shift point in the target
region and repeat

\end{itemize}

\end{fulllineitems}



\section{solver}
\label{index:module-solver}\label{index:solver}\index{solver (module)}
Function for the generalized eigenvalue problem

Input
A x = lamda B x
evs\_per\_shift: no of eigenvalues required
kind: largest or smallest in magnitude. parameters `LM', `SM' respectively
flag: flag should be passed true when B is positive definite
\begin{description}
\item[{Output}] \leavevmode\begin{enumerate}
\item {} 
la (Array of evs\_per\_shift eigenvalues.)

\item {} \begin{description}
\item[{v (An array of evs\_per\_shift eigenvectors. v{[}:, i{]} is the eigenvector }] \leavevmode
corresponding to the eigenvalue la{[}i{]})

\end{description}

\end{enumerate}

\end{description}

Additional Info
Example of eigs
eigs(A, k=6, M=None, sigma=None, which='LM', v0=None, ncv=None, maxiter=None, tol=0,
return\_eigenvectors=True, Minv=None, OPinv=None, OPpart=None)

The eigs function of PYTHON can calculate the eigenvalues of the generalized eigenvalue
problem A*x=lamda*M*x with the following conditions.
M must represent a real, symmetric matrix if A is real, and must represent a complex, 
hermitian matrix if A is complex.
If sigma is None, M has to be positive definite 
If sigma is specified, M has to be positive semi-definite

When sigma is specified `say 0' then eigs function will calculate the eigenvalues nearest to sigma. 
The `LM' clause along with sigma = 0 can be used to calculate the reciprocal eigenvalues of 
Largest Magnitude.


\section{cover}
\label{index:cover}\label{index:module-cover}\index{cover (module)}
Implementation of the MonteCarlo Algorithm for choosing shift points to cover the target region

cover.next\_shift
Input
1. target (target region for the shift points)
2. previous\_shifts (python list for the previous shift points already calculated)
3. previous\_radius (corresponding radius of the previous shift points)

Output
1. next\_shift (next shift point in the target region)
\index{next\_shift() (in module cover)}

\begin{fulllineitems}
\phantomsection\label{index:cover.next_shift}\pysiglinewithargsret{\code{cover.}\bfcode{next\_shift}}{\emph{obj}, \emph{previous\_shifts=}\optional{}, \emph{previous\_radius=}\optional{}}{}
Obtain the next shift in the target region

\end{fulllineitems}



\chapter{analyze}
\label{index:analyze}

\section{residual}
\label{index:residual}\label{index:module-residual}\index{residual (module)}
Function definitions for obtaining the residual


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{\_}
\item {\texttt{\_\_init\_\_}}, \pageref{index:module-__init__}
\indexspace
\bigletter{a}
\item {\texttt{assemble}}, \pageref{index:module-assemble}
\indexspace
\bigletter{c}
\item {\texttt{cover}}, \pageref{index:module-cover}
\indexspace
\bigletter{d}
\item {\texttt{diagscale}}, \pageref{index:module-diagscale}
\indexspace
\bigletter{l}
\item {\texttt{load}}, \pageref{index:module-load}
\item {\texttt{logger}}, \pageref{index:module-logger}
\indexspace
\bigletter{p}
\item {\texttt{projection}}, \pageref{index:module-projection}
\indexspace
\bigletter{q}
\item {\texttt{qevp}}, \pageref{index:module-qevp}
\indexspace
\bigletter{r}
\item {\texttt{residual}}, \pageref{index:module-residual}
\indexspace
\bigletter{s}
\item {\texttt{scale}}, \pageref{index:module-scale}
\item {\texttt{shift}}, \pageref{index:module-shift}
\item {\texttt{solver}}, \pageref{index:module-solver}
\indexspace
\bigletter{u}
\item {\texttt{unlinearize}}, \pageref{index:module-unlinearize}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
