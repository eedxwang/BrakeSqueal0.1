% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{BrakeSqueal Documentation}
\date{February 23, 2015}
\release{0.1}
\author{Ali H. Kadar}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{brake}
\label{index:brake}\label{index:welcome-to-brakesqueal-s-documentation}

\section{\_\_init\_\_}
\label{index:init}
\href{https://bitbucket.org/akadar/brakesqueal0.1/src/master/brake/\_\_init\_\_.py?at=master}{Source}
\phantomsection\label{index:module-brake.__init__}\index{brake.\_\_init\_\_ (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
- BrakeClass:

  Python parent class for the BrakeSqueal Project.
  
- printEigs:
  
  Prints the required eigenvalues in a file/terminal (with two floating points).
  
- extractEigs:
 
  Extracts the required eigenpairs.
  
- save
  
  Saves a figure from pyplot.
\end{Verbatim}
\index{BrakeClass (class in brake.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{index:brake.__init__.BrakeClass}\pysiglinewithargsret{\strong{class }\code{brake.\_\_init\_\_.}\bfcode{BrakeClass}}{\emph{input\_path}, \emph{output\_path}, \emph{info\_log\_file}, \emph{time\_log\_file}, \emph{log\_level}}{}
Member Functions of the BrakeClass:
\begin{itemize}
\item {} 
\_\_init\_\_

\item {} 
createInfoLogger

\item {} 
createTimeLogger

\item {} 
displayCount

\item {} 
displayParametersConsole

\item {} 
displayParametersLog

\end{itemize}

\end{fulllineitems}

\index{printEigs() (in module brake.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{index:brake.__init__.printEigs}\pysiglinewithargsret{\code{brake.\_\_init\_\_.}\bfcode{printEigs}}{\emph{obj}, \emph{eigenValues}, \emph{which\_flag}, \emph{where\_flag}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{obj} -- object of the class \code{BrakeClass}

\item {} 
\textbf{eigenValues} -- eigenvalues

\item {} 
\textbf{which\_flag} -- which eigenvalues are needed(`all' or `target' or `critical' or `positive')

\item {} 
\textbf{where\_flag} -- where to print the eigenvalues(`terminal' or `file')

\end{itemize}

\item[{Returns}] \leavevmode
prints eigenvalues in the desired format(upto 2 decimal places)

\end{description}\end{quote}

\end{fulllineitems}

\index{extractEigs() (in module brake.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{index:brake.__init__.extractEigs}\pysiglinewithargsret{\code{brake.\_\_init\_\_.}\bfcode{extractEigs}}{\emph{obj}, \emph{eigenValues}, \emph{eigenVectors}, \emph{which\_flag}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{obj} -- object of the class \code{BrakeClass}

\item {} 
\textbf{eigenValues} -- eigenvalues

\item {} 
\textbf{eigenVectors} -- eigenvectors

\item {} 
\textbf{which\_flag} -- which eigenvalues are needed(`all' or `target' or `critical' or `positive')

\end{itemize}

\item[{Returns}] \leavevmode
\code{laExtracted} - required eigenvalues, \code{evecExtracted} -- corresponding eigenvectors

\end{description}\end{quote}

\end{fulllineitems}

\index{save() (in module brake.\_\_init\_\_)}

\begin{fulllineitems}
\phantomsection\label{index:brake.__init__.save}\pysiglinewithargsret{\code{brake.\_\_init\_\_.}\bfcode{save}}{\emph{path}, \emph{ext='png'}, \emph{close=False}, \emph{verbose=True}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{path} -- string
The path (and filename, without the extension) to save the
figure to.

\item {} 
\textbf{ext} -- string (default='png')
The file extension. This must be supported by the active
matplotlib backend (see matplotlib.backends module).  Most
backends support `png', `pdf', `ps', `eps', and `svg'.

\item {} 
\textbf{close} -- boolean (default=True)
Whether to close the figure after saving.  If you want to save
the figure multiple times (e.g., to multiple formats), you
should NOT close it in between saves or you will have to
re-plot it.

\item {} 
\textbf{verbose} -- boolean (default=True)
Whether to print information about when and where the image
has been saved.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\strong{See Also:}


{\hyperref[index:logger]{logger}}  brake.initialize.logger




\chapter{initialize}
\label{index:initialize}

\section{logger}
\label{index:logger}
\href{https://bitbucket.org/akadar/brakesqueal0.1/src/master/brake/initialize/logger.py?at=master}{Source}
\phantomsection\label{index:module-brake.initialize.logger}\index{brake.initialize.logger (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
- return\_info\_logger:
  
  Creates and returns a python logger object for information logging
  
- return\_time\_logger:
  
  Creates and returns a python logger object for time logging
\end{Verbatim}

Note:

\begin{Verbatim}[commandchars=\\\{\}]
various logging levels
LEVELS = \PYGZob{}'notset':logging.NOTSET, \#0 --\textgreater{} numerical value (for no logging)
         'debug': logging.DEBUG, \#10 (to capture detailed debug information)
         'info': logging.INFO, \#20 (to capture essential information)
         'warning': logging.WARNING, \#30
         'error': logging.ERROR, \#40
         'critical': logging.CRITICAL\PYGZcb{} \#50
\end{Verbatim}
\index{return\_info\_logger() (in module brake.initialize.logger)}

\begin{fulllineitems}
\phantomsection\label{index:brake.initialize.logger.return_info_logger}\pysiglinewithargsret{\code{brake.initialize.logger.}\bfcode{return\_info\_logger}}{\emph{obj}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{obj} -- object of the class \code{BrakeClass}

\item[{Returns}] \leavevmode
logger\_i - python logger object for information logging

\end{description}\end{quote}

\end{fulllineitems}

\index{return\_time\_logger() (in module brake.initialize.logger)}

\begin{fulllineitems}
\phantomsection\label{index:brake.initialize.logger.return_time_logger}\pysiglinewithargsret{\code{brake.initialize.logger.}\bfcode{return\_time\_logger}}{\emph{obj}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{obj} -- object of the class \code{BrakeClass}

\item[{Returns}] \leavevmode
logger\_t - python logger object for time logging

\end{description}\end{quote}

\end{fulllineitems}



\strong{See Also:}


\href{https://docs.python.org/2/library/logging.html}{Python Logging}




\section{load}
\label{index:load}
\href{https://bitbucket.org/akadar/brakesqueal0.1/src/master/brake/initialize/load.py?at=master}{Source}
\phantomsection\label{index:module-brake.initialize.load}\index{brake.initialize.load (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
- load\_matrices:

  This function loads the sparse data matrices in .mat format and adds them to a python list
\end{Verbatim}
\index{load\_matrices() (in module brake.initialize.load)}

\begin{fulllineitems}
\phantomsection\label{index:brake.initialize.load.load_matrices}\pysiglinewithargsret{\code{brake.initialize.load.}\bfcode{load\_matrices}}{\emph{obj}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{obj} -- object of the class \code{BrakeClass}

\item[{Returns}] \leavevmode
sparse\_list -- a python list of matrices in Compressed Sparse Column format 
of type `\textless{}type `numpy.float64'\textgreater{}'

\end{description}\end{quote}

Procedure:

\begin{Verbatim}[commandchars=\\\{\}]
The sparse\_list is obtained by loading the vaious .mat files present in the
data\_file\_list attribute of the BrakeClass and then appending them into
a python list sparse\_list.
\end{Verbatim}

\end{fulllineitems}



\strong{See Also:}


\href{http://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.io.loadmat.html}{scipy.io.loadmat}




\section{assemble}
\label{index:assemble}
\href{https://bitbucket.org/akadar/brakesqueal0.1/src/master/brake/initialize/assemble.py?at=master}{Source}
\phantomsection\label{index:module-brake.initialize.assemble}\index{brake.initialize.assemble (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
- create\_MCK:

  Assembles the various component matrices together(for the given angular frequency
  omega) to form the mass(M), damping(C) and stiffness matrix(K).
\end{Verbatim}
\index{create\_MCK() (in module brake.initialize.assemble)}

\begin{fulllineitems}
\phantomsection\label{index:brake.initialize.assemble.create_MCK}\pysiglinewithargsret{\code{brake.initialize.assemble.}\bfcode{create\_MCK}}{\emph{obj}, \emph{sparse\_list}, \emph{omega}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{obj} -- object of the class \code{BrakeClass}

\item {} 
\textbf{sparse\_list} -- a python list of matrices in Compressed Sparse Column format 
of type `\textless{}type `numpy.float64'\textgreater{}',

\item {} 
\textbf{omega} -- angular frequency

\end{itemize}

\item[{Returns}] \leavevmode
M - Mass Matrix, C - Damping Matrix, K - Stiffness Matrix

\item[{Raises }] \leavevmode
Assemble\_BadInputError, When a matrix in the list is not sparse

\item[{Raises }] \leavevmode
Assemble\_BadInputError, When a matrix in the list is not square

\item[{Raises }] \leavevmode
Assemble\_BadInputError, When the matrix  are not of the same size

\end{description}\end{quote}

Procedure:

\begin{Verbatim}[commandchars=\\\{\}]
The M , C , K are assembled as follows:

- M = M1
- C = D1+DR*(omegaRef/omega)+DG*(omega/omegaRef)
- K = K1+KR+KGeo*math.pow((omega/omegaRef),2)
\end{Verbatim}

\end{fulllineitems}



\strong{See Also:}


\href{http://docs.scipy.org/doc/scipy-dev/reference/generated/scipy.sparse.linalg.onenormest.html}{scipy.sparse.linalg.onenormest}




\section{shift}
\label{index:shift}
\href{https://bitbucket.org/akadar/brakesqueal0.1/src/master/brake/initialize/shift.py?at=master}{Source}
\phantomsection\label{index:module-brake.initialize.shift}\index{brake.initialize.shift (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
- shift\_matrices:

  Transform the qevp using shift and invert spectral transformations.
\end{Verbatim}
\index{shift\_matrices() (in module brake.initialize.shift)}

\begin{fulllineitems}
\phantomsection\label{index:brake.initialize.shift.shift_matrices}\pysiglinewithargsret{\code{brake.initialize.shift.}\bfcode{shift\_matrices}}{\emph{obj}, \emph{m}, \emph{c}, \emph{k}, \emph{tau}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{obj} -- object of the class \code{BrakeClass}

\item {} 
\textbf{m} -- Mass Matrix

\item {} 
\textbf{c} -- Damping Matrix

\item {} 
\textbf{k} -- Stiffness Matrix

\item {} 
\textbf{tau} -- Shift

\end{itemize}

\item[{Returns}] \leavevmode
M, C, K - Shifted Mass, Damping and Stiffness Matrix respectively

\end{description}\end{quote}

Procedure:

\begin{Verbatim}[commandchars=\\\{\}]
The M , C , K are obtained as follows:

 M = m
 C = 2 * tau * m + c
 K = tau\_squared * m + tau * c + k
\end{Verbatim}

\end{fulllineitems}



\strong{See Also:}


\href{http://docs.scipy.org/doc/scipy-dev/reference/generated/scipy.sparse.linalg.onenormest.html}{scipy.sparse.linalg.onenormest}




\section{scale}
\label{index:scale}
\href{https://bitbucket.org/akadar/brakesqueal0.1/src/master/brake/initialize/scale.py?at=master}{Source}
\phantomsection\label{index:module-brake.initialize.scale}\index{brake.initialize.scale (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
- scale\_matrices:

  Scales the M, C, K matrices using 2-scalers before linearization.
\end{Verbatim}
\index{scale\_matrices() (in module brake.initialize.scale)}

\begin{fulllineitems}
\phantomsection\label{index:brake.initialize.scale.scale_matrices}\pysiglinewithargsret{\code{brake.initialize.scale.}\bfcode{scale\_matrices}}{\emph{obj}, \emph{m}, \emph{c}, \emph{k}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{obj} -- object of the class \code{BrakeClass}

\item {} 
\textbf{m} -- Mass Matrix

\item {} 
\textbf{c} -- Damping Matrix

\item {} 
\textbf{k} -- Stiffness Matrix

\end{itemize}

\item[{Returns}] \leavevmode
M, C, K - Scaled Mass, Damping and Stiffness Matrix respectively

\item[{Returns}] \leavevmode
scaling parameters, - gamma and delta.

\end{description}\end{quote}

Procedure:

\begin{Verbatim}[commandchars=\\\{\}]
The M , C , K, gamma, delta  are obtained as follows:

M = gamma*gamma*delta*m;
C = gamma*delta*c;
K = delta*k;
gamma = math.sqrt(k\_norm/m\_norm);
delta = 2/(k\_norm+c\_norm*gamma);
\end{Verbatim}

Note:

\begin{Verbatim}[commandchars=\\\{\}]
scipy.sparse.linalg.onenormest - Computes a lower bound of the 1-norm of a sparse matrix.
In the disk brake modelling theory spectral norm has been used but since I could not
find a better(less computational cost) way to obtain this in python, I have used 1-norm
approximation
\end{Verbatim}

\end{fulllineitems}



\strong{See Also:}


\href{http://docs.scipy.org/doc/scipy-dev/reference/generated/scipy.sparse.linalg.onenormest.html}{scipy.sparse.linalg.onenormest}




\section{diagscale}
\label{index:diagscale}
\href{https://bitbucket.org/akadar/brakesqueal0.1/src/master/brake/initialize/diagscale.py?at=master}{Source}
\phantomsection\label{index:module-brake.initialize.diagscale}\index{brake.initialize.diagscale (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
- normalize\_cols:

  Returns a diagonal matrix D such that every column of A*D has eucledian norm = 1. 
  
- norm\_rc:

  Returns diagonal matrix DL and DR such that every row and every column of DL*Y*DR
  has euclidean norm \textasciitilde{} 1.

- diag\_scale\_matrices:

  Diagonally scales the shifted scalar-scaled matrices using DL, DR to improve the
  condition number.
\end{Verbatim}
\index{diag\_scale\_matrices() (in module brake.initialize.diagscale)}

\begin{fulllineitems}
\phantomsection\label{index:brake.initialize.diagscale.diag_scale_matrices}\pysiglinewithargsret{\code{brake.initialize.diagscale.}\bfcode{diag\_scale\_matrices}}{\emph{obj}, \emph{M}, \emph{C}, \emph{K}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{obj} -- object of the class \code{BrakeClass}

\item {} 
\textbf{M} -- Mass Matrix

\item {} 
\textbf{C} -- Damping Matrix

\item {} 
\textbf{K} -- Stiffness Matrix

\end{itemize}

\item[{Returns}] \leavevmode
M, C, K - Diagonally Scaled  Mass, Damping and Stiffness Matrix respectively

\item[{Returns}] \leavevmode
DR - Matrix that normalize the columns

\end{description}\end{quote}

Procedure:

\begin{Verbatim}[commandchars=\\\{\}]
The M , C , K, DR  are obtained as follows:

M = DL * M * DR
C = DL * C * DR
K = DL * K * DR
\end{Verbatim}

\end{fulllineitems}

\index{norm\_rc() (in module brake.initialize.diagscale)}

\begin{fulllineitems}
\phantomsection\label{index:brake.initialize.diagscale.norm_rc}\pysiglinewithargsret{\code{brake.initialize.diagscale.}\bfcode{norm\_rc}}{\emph{Y}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{Y} -- -- matrix that needs to be normalized across both columns and rows

\item[{Returns}] \leavevmode
\code{DL} = ..... \code{Drow3} * \code{Drow2} * \code{Drow1} * \code{I}

\item[{Returns}] \leavevmode
\code{DR} = \code{I} * \code{Dcol1} * \code{Dcol2} * \code{Dcol3}......

\end{description}\end{quote}

Procedure:

\begin{Verbatim}[commandchars=\\\{\}]
The DL and DR are obtained as a converging sequence :

set Dcol = normalize columns(Y)
set DR = DR * Dcol
set Y = Y * Dcol
set Drow = normalize rows(Y) = normalize columns(Y.T)
set DL = Drow * DL
set Y = Drow * Y
when Dcol and Drow are sufficiently close to I or max no of iterations reached
STOP and return, else continue with step 1.
\end{Verbatim}

\end{fulllineitems}

\index{normalize\_cols() (in module brake.initialize.diagscale)}

\begin{fulllineitems}
\phantomsection\label{index:brake.initialize.diagscale.normalize_cols}\pysiglinewithargsret{\code{brake.initialize.diagscale.}\bfcode{normalize\_cols}}{\emph{A}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{A} -- -- matrix that needs to be normalized(columnwise)

\item[{Returns}] \leavevmode
\code{D} - diagonal matrix such that every column of \code{A*D} has eucledian norm = 1.

\end{description}\end{quote}

Procedure:

\begin{Verbatim}[commandchars=\\\{\}]
D is obtained as follows:
square the elements of A and sum each column
set the diagonal elemnts of D as the inverse square root of the column sums
\end{Verbatim}

\end{fulllineitems}



\strong{See Also:}

\begin{description}
\item[{\href{http://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.sparse.linalg.eigs.html}{scipy.sparse.linalg.eigs}}] \leavevmode
Documentation of the Python eigs command

\end{description}




\section{unlinearize}
\label{index:unlinearize}
\href{https://bitbucket.org/akadar/brakesqueal0.1/src/master/brake/initialize/unlinearize.py?at=master}{Source}
\phantomsection\label{index:module-brake.initialize.unlinearize}\index{brake.initialize.unlinearize (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
- unlinearize\_matrices:
  
  To obtain the eigenvectors prior linearization of the QEVP from the 
  resulting eigenvectors (after classical companion linearization of the QEVP
  to obtain the generalized eigenvalue propblem).
\end{Verbatim}
\index{unlinearize\_matrices() (in module brake.initialize.unlinearize)}

\begin{fulllineitems}
\phantomsection\label{index:brake.initialize.unlinearize.unlinearize_matrices}\pysiglinewithargsret{\code{brake.initialize.unlinearize.}\bfcode{unlinearize\_matrices}}{\emph{evec}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{evec} -- eigenvectors of the generalized eigenvalue propblem

\item[{Returns}] \leavevmode
evec\_prior - eigenvectors prior linearization of the QEVP

\end{description}\end{quote}

Procedure:

\begin{Verbatim}[commandchars=\\\{\}]
The evec\_prior are obtained as follows:

check for every vector i of the GEVP(evec) (consider MATLAB convention)
if norm(evec[1:n,i]) \textgreater{} norm(evec[n+1:2*n,i]) set evec\_prior[:,i] = evec[1:n,i]
else set evec\_prior[:,i] = evec[n+1:2*n,i]
\end{Verbatim}

\end{fulllineitems}



\strong{See Also:}


{\hyperref[index:diagscale]{diagscale}}  brake.initialize.diagscale




\chapter{solve}
\label{index:solve}

\section{projection}
\label{index:projection}
\href{https://bitbucket.org/akadar/brakesqueal0.1/src/master/brake/solve/projection.py?at=master}{Source}
\phantomsection\label{index:module-brake.solve.projection}\index{brake.solve.projection (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
- obtain\_projection\_matrix:

 This function obtains the Projection Matrix from a given measurment matrix.
 
 - obtain\_measurment\_matrix
 
 This function forms the Measurment Matrix by solving the quadratic eigenvalue problem 
 for each base angular frequency.
\end{Verbatim}
\index{obtain\_measurment\_matrix() (in module brake.solve.projection)}

\begin{fulllineitems}
\phantomsection\label{index:brake.solve.projection.obtain_measurment_matrix}\pysiglinewithargsret{\code{brake.solve.projection.}\bfcode{obtain\_measurment\_matrix}}{\emph{obj}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{obj} -- object of the class \code{BrakeClass}

\item[{Returns}] \leavevmode
\code{X} - measurment matrix

\end{description}\end{quote}

Procedure:

\begin{Verbatim}[commandchars=\\\{\}]
The measurment matrix is obtained as follows:

- Obtain the measurment matrix X = [X\_real X\_imag], with X\_real as a list of 
  real parts of eigenvectors and X\_imag as a list of imaginary parts of 
  eigenvectors, corresponding to each base angular frequency in omega\_basis.
\end{Verbatim}

\end{fulllineitems}

\index{obtain\_projection\_matrix() (in module brake.solve.projection)}

\begin{fulllineitems}
\phantomsection\label{index:brake.solve.projection.obtain_projection_matrix}\pysiglinewithargsret{\code{brake.solve.projection.}\bfcode{obtain\_projection\_matrix}}{\emph{obj}, \emph{X}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{obj} -- object of the class \code{BrakeClass}

\item {} 
\textbf{X} -- measurment matrix

\end{itemize}

\item[{Returns}] \leavevmode
\code{Q} - projection matrix

\end{description}\end{quote}

Procedure:

\begin{Verbatim}[commandchars=\\\{\}]
The projection matrix is obtained as follows:

- Compute the thin svd of the measurment matrix. X = U * s * V
- Set Q = truncated(U), where the truncation is done to take only the significant 
  singular values(provided by user in obj.projectionDimension) into account
\end{Verbatim}

\end{fulllineitems}



\strong{See Also:}


\href{http://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.linalg.svd.html}{scipy.linalg.svd}




\section{traditional projection}
\label{index:traditional-projection}
\href{https://bitbucket.org/akadar/brakesqueal0.1/src/master/brake/solve/traditionalProjection.py?at=master}{Source}
\phantomsection\label{index:module-brake.solve.traditionalProjection}\index{brake.solve.traditionalProjection (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
- Obtain\_eigs:
  
  Determines required number of eigenvalues and associated eigenvectors of the simplified system with
  symmetric coefficients according to the classical modal transformation approach.
\end{Verbatim}
\index{Obtain\_eigs() (in module brake.solve.traditionalProjection)}

\begin{fulllineitems}
\phantomsection\label{index:brake.solve.traditionalProjection.Obtain_eigs}\pysiglinewithargsret{\code{brake.solve.traditionalProjection.}\bfcode{Obtain\_eigs}}{\emph{obj}, \emph{no\_of\_evs}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{obj} -- object of the class \code{BrakeClass}

\item {} 
\textbf{no\_of\_evs} -- the required number of eigenvalues to be covered close to the center of the target region

\end{itemize}

\item[{Returns}] \leavevmode
\code{la} - eigenvalues, \code{evec} - eigenvectors

\end{description}\end{quote}

Procedure:

\begin{Verbatim}[commandchars=\\\{\}]
The la and evec are obtained as follows:
  
- load the various component matrices.
- assemble the various component matrices together to form the mass(M) and stiffness matrix(K)
  according to the classical modal transformation approach.
- because we are interested in inner eigenvalues around a certain shift point, 
  so we transform the qevp using shift and invert spectral transformations.
\end{Verbatim}

\end{fulllineitems}



\strong{See Also:}


\href{http://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.linalg.svd.html}{scipy.linalg.svd}




\section{qevp}
\label{index:qevp}
\href{https://bitbucket.org/akadar/brakesqueal0.1/src/master/brake/solve/qevp.py?at=master}{Source}
\phantomsection\label{index:module-brake.solve.qevp}\index{brake.solve.qevp (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
- brake\_squeal\_qevp:

  For a particuar base angular frequency this function assembles the eigenvalues
  and eigenvectors for different shift points in the target region.
  
- Obtain\_eigs:
  
  For a particuar base angular frequency and for a particular shift point this 
  function obtains obj.evs\_per\_shift eigenvalues and the corresponding eigenvectors
\end{Verbatim}
\index{Obtain\_eigs() (in module brake.solve.qevp)}

\begin{fulllineitems}
\phantomsection\label{index:brake.solve.qevp.Obtain_eigs}\pysiglinewithargsret{\code{brake.solve.qevp.}\bfcode{Obtain\_eigs}}{\emph{obj}, \emph{freq\_i}, \emph{qevp\_j}, \emph{omega}, \emph{next\_shift}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{obj} -- object of the class \code{BrakeClass}

\item {} 
\textbf{freq\_i} -- the index of the base angular freq

\item {} 
\textbf{qevp\_j} -- the index of the shift point

\item {} 
\textbf{omega} -- ith base angular freq

\item {} 
\textbf{next\_shift} -- jth shift point in the target region

\end{itemize}

\item[{Returns}] \leavevmode
\code{la} - eigenvalues, \code{evec} - eigenvectors

\end{description}\end{quote}

Procedure:

\begin{Verbatim}[commandchars=\\\{\}]
The la and evec are obtained as follows:
  
- load the various component matrices
- assemble the various component matrices together(for the given angular frequency
  omega) to form the mass(M), damping(C) and stiffness matrix(K).
- because we are interested in inner eigenvalues around certain shift points
  next\_shift, so we transform the qevp using shift and invert spectral
  transformations.
\end{Verbatim}

\end{fulllineitems}

\index{brake\_squeal\_qevp() (in module brake.solve.qevp)}

\begin{fulllineitems}
\phantomsection\label{index:brake.solve.qevp.brake_squeal_qevp}\pysiglinewithargsret{\code{brake.solve.qevp.}\bfcode{brake\_squeal\_qevp}}{\emph{obj}, \emph{freq\_i}, \emph{omega}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{obj} -- object of the class \code{BrakeClass}

\item {} 
\textbf{freq\_i} -- the index of the base angular freq

\item {} 
\textbf{omega} -- ith base angular freq

\end{itemize}

\item[{Returns}] \leavevmode
\code{assembled\_la} - assembled eigenvalues, \code{assembled\_evec} -- assembled eigenvectors

\end{description}\end{quote}

Procedure:

\begin{Verbatim}[commandchars=\\\{\}]
The assembled\_la and assembled\_evec are obtained as follows:
  
- calculate the next shift point in the target region
- obtain eigenvalues and eigenvectors for that particular shift point
- add the eigenvalues and eigenvectors to assembled\_la and assembled\_evec respectively
- check if the required area fraction of the target region has been covered. If yes return
  assembled\_la and assembled\_evec else calculate the next shift point in the target
  region and repeat
\end{Verbatim}

\end{fulllineitems}



\section{solver}
\label{index:solver}
\href{https://bitbucket.org/akadar/brakesqueal0.1/src/master/brake/solve/solver.py?at=master}{Source}
\phantomsection\label{index:module-brake.solve.solver}\index{brake.solve.solver (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
- qev\_sparse:

  Obtains the eigenvalues(smallest in magnitude) and corresponding eigenvectors 
  for the given Quadratic Eigenvalue Problem(QEVP) with sparse M, C, K matrices.
 
- qev\_dense

  Obtains the eigenvalues(smallest in magnitude) and corresponding eigenvectors 
  for the given Quadratic Eigenvalue Problem(QEVP) with dense M, C, K matrices.
    
- gev\_sparse

  Obtains the eigenvalues(smallest in magnitude) and corresponding eigenvectors 
  for the Generalized Eigenvalue Problem(GEVP) with sparse A, B matrices. 
  
- gev\_dense

  Obtains the eigenvalues(smallest in magnitude) and corresponding eigenvectors 
  for the Generalized Eigenvalue Problem(GEVP) with dense A, B matrices.
\end{Verbatim}

Note:

\begin{Verbatim}[commandchars=\\\{\}]
The eigs function of PYTHON can calculate the eigenvalues of the generalized eigenvalue
problem A*x=lamda*M*x with the following conditions.
M must represent a real, symmetric matrix if A is real, and must represent a complex, 
hermitian matrix if A is complex.
If sigma is None, M has to be positive definite 
If sigma is specified, M has to be positive semi-definite

When sigma is specified 'ex 0' then eigs function will calculate the eigenvalues nearest to sigma. 
The 'LM' clause along with sigma = 0 can be used to calculate the reciprocal eigenvalues of 
Largest Magnitude.
\end{Verbatim}
\index{gev\_dense() (in module brake.solve.solver)}

\begin{fulllineitems}
\phantomsection\label{index:brake.solve.solver.gev_dense}\pysiglinewithargsret{\code{brake.solve.solver.}\bfcode{gev\_dense}}{\emph{obj}, \emph{A}, \emph{B}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{obj} -- object of the class \code{BrakeClass}

\item {} 
\textbf{A} -- \code{A x = lamda B x}

\item {} 
\textbf{B} -- \code{A x = lamda B x}

\end{itemize}

\item[{Returns}] \leavevmode
\code{la} - eigenvalues, \code{v} - eigenvectors

\item[{Raises }] \leavevmode
\code{SOLVER\_BadInputError}, When the matrix A, B are not all dense

\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
.
\end{Verbatim}

\end{fulllineitems}

\index{gev\_sparse() (in module brake.solve.solver)}

\begin{fulllineitems}
\phantomsection\label{index:brake.solve.solver.gev_sparse}\pysiglinewithargsret{\code{brake.solve.solver.}\bfcode{gev\_sparse}}{\emph{obj}, \emph{A}, \emph{B}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{obj} -- object of the class \code{BrakeClass}

\item {} 
\textbf{A} -- \code{A x = lamda B x}

\item {} 
\textbf{B} -- \code{A x = lamda B x}

\end{itemize}

\item[{Returns}] \leavevmode
\code{la} - eigenvalues, \code{v} - eigenvectors

\item[{Raises }] \leavevmode
\code{SOLVER\_BadInputError}, When the matrix A, B are not all in sparse format

\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
.
\end{Verbatim}

\end{fulllineitems}

\index{qev\_dense() (in module brake.solve.solver)}

\begin{fulllineitems}
\phantomsection\label{index:brake.solve.solver.qev_dense}\pysiglinewithargsret{\code{brake.solve.solver.}\bfcode{qev\_dense}}{\emph{obj}, \emph{M}, \emph{C}, \emph{K}, \emph{no\_of\_evs}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{obj} -- object of the class \code{BrakeClass}

\item {} 
\textbf{M} -- Mass Matrix

\item {} 
\textbf{C} -- Damping Matrix

\item {} 
\textbf{K} -- Stiffness Matrix

\item {} 
\textbf{no\_of\_evs} -- No of eigenvalues to be computed

\end{itemize}

\item[{Returns}] \leavevmode
\code{la} - eigenvalues, \code{v} - eigenvectors

\item[{Raises }] \leavevmode
\code{SOLVER\_BadInputError}, When the matrix M,C,K are not all dense

\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
.
\end{Verbatim}

\end{fulllineitems}

\index{qev\_sparse() (in module brake.solve.solver)}

\begin{fulllineitems}
\phantomsection\label{index:brake.solve.solver.qev_sparse}\pysiglinewithargsret{\code{brake.solve.solver.}\bfcode{qev\_sparse}}{\emph{obj}, \emph{M}, \emph{C}, \emph{K}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{obj} -- object of the class \code{BrakeClass}

\item {} 
\textbf{M} -- Mass Matrix

\item {} 
\textbf{C} -- Damping Matrix

\item {} 
\textbf{K} -- Stiffness Matrix

\end{itemize}

\item[{Returns}] \leavevmode
\code{la} - eigenvalues, \code{v} - eigenvectors

\item[{Raises }] \leavevmode
\code{SOLVER\_BadInputError}, When the matrix M,C,K are not all in sparse format

\end{description}\end{quote}

Example:

\begin{Verbatim}[commandchars=\\\{\}]
.
\end{Verbatim}

\end{fulllineitems}



\strong{See Also:}

\begin{description}
\item[{\href{http://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.sparse.linalg.eigs.html}{scipy.sparse.linalg.eigs}}] \leavevmode
Documentation of the Python eigs command

\item[{\href{http://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.sparse.linalg.splu.html}{scipy.sparse.linalg.splu}}] \leavevmode
Documentation of the Python splu command

\item[{\href{http://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.sparse.linalg.spilu.html}{scipy.sparse.linalg.spilu}}] \leavevmode
Documentation of the Python spilu command

\item[{\href{http://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.linalg.lu\_factor.html}{scipy.linalg.lu\_factor}}] \leavevmode
Documentation of the Python lu\_factor command

\item[{\href{http://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.linalg.lu\_solve.html}{scipy.linalg.lu\_solve}}] \leavevmode
Documentation of the Python lu\_solve command

\end{description}




\section{cover}
\label{index:cover}
\href{https://bitbucket.org/akadar/brakesqueal0.1/src/master/brake/solve/cover.py?at=master}{Source}
\phantomsection\label{index:module-brake.solve.cover}\index{brake.solve.cover (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
- next\_shift

  Implementation of the MonteCarlo Algorithm for choosing the next shift point 
  in the target region.

- calculate\_area\_fraction

  Calculates the area fraction covered(of the target rectangle) by the chosen shift points.
  
- draw\_circles

  plots a circle corresponding to the next shift point and appends it to the existing plot.
  Thus creates a simulation showing how the target region is covered by the various shift points
  chosen on fly.
\end{Verbatim}
\index{calculate\_area\_fraction() (in module brake.solve.cover)}

\begin{fulllineitems}
\phantomsection\label{index:brake.solve.cover.calculate_area_fraction}\pysiglinewithargsret{\code{brake.solve.cover.}\bfcode{calculate\_area\_fraction}}{\emph{obj}, \emph{previous\_shifts}, \emph{previous\_radius}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{obj} -- object of the class \code{BrakeClass}

\item {} 
\textbf{previous\_shifts} -- python list for the previous shift points already calculated

\item {} 
\textbf{previous\_radius} -- corresponding radius of the previous shift points

\end{itemize}

\item[{Returns}] \leavevmode
\code{area\_fraction\_covered} - the total area fraction covered with the chosen shift points

\item[{Raises }] \leavevmode
\code{Cover\_BadInputError}, When the provided input is not as expected

\end{description}\end{quote}

\end{fulllineitems}

\index{draw\_circles() (in module brake.solve.cover)}

\begin{fulllineitems}
\phantomsection\label{index:brake.solve.cover.draw_circles}\pysiglinewithargsret{\code{brake.solve.cover.}\bfcode{draw\_circles}}{\emph{obj}, \emph{next\_shift}, \emph{next\_radius}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{obj} -- object of the class \code{BrakeClass}

\item {} 
\textbf{next\_shift} -- the shift point to be shown on the plot

\item {} 
\textbf{next\_radius} -- the radius of the shift point to be shown

\end{itemize}

\item[{Returns}] \leavevmode
plots a circle corresponding to the next shift point and appends it to the existing plot.

\item[{Raises }] \leavevmode
\code{Cover\_BadInputError}, When the provided input is not as expected

\end{description}\end{quote}

\end{fulllineitems}

\index{next\_shift() (in module brake.solve.cover)}

\begin{fulllineitems}
\phantomsection\label{index:brake.solve.cover.next_shift}\pysiglinewithargsret{\code{brake.solve.cover.}\bfcode{next\_shift}}{\emph{obj}, \emph{previous\_shifts=}\optional{}, \emph{previous\_radius=}\optional{}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{obj} -- object of the class \code{BrakeClass}

\item {} 
\textbf{previous\_shifts} -- python list for the previous shift points already calculated

\item {} 
\textbf{previous\_radius} -- corresponding radius of the previous shift points

\end{itemize}

\item[{Returns}] \leavevmode
\code{next\_shift} - next shift point in the target region

\item[{Raises }] \leavevmode
\code{Cover\_BadInputError}, When the provided input is not as expected

\end{description}\end{quote}

\end{fulllineitems}



\strong{See Also:}

\begin{description}
\item[{\href{http://matplotlib.org/api/pyplot\_api.html}{matplotlib.pyplot}}] \leavevmode
Documentation of the Python Matplotlib library

\item[{\href{https://docs.python.org/2/library/random.html}{randon.py}}] \leavevmode
Documentation of the Python random number generator module

\end{description}




\chapter{analyze}
\label{index:analyze}

\section{residual}
\label{index:residual}
\href{https://bitbucket.org/akadar/brakesqueal0.1/src/master/brake/analyze/residual.py?at=master}{Source}
\phantomsection\label{index:module-brake.analyze.residual}\index{brake.analyze.residual (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
- residual\_qevp:

  Calculates the relative residual of the Quadratic Eigenvalue Problem (lamda\textasciicircum{}2 M + lamda C + K) X = 0

- residual\_gevp

  Calculates the relative residual of the Generalized Eigenvalue Problem (A - lamda B) X = 0
\end{Verbatim}
\index{residual\_gevp() (in module brake.analyze.residual)}

\begin{fulllineitems}
\phantomsection\label{index:brake.analyze.residual.residual_gevp}\pysiglinewithargsret{\code{brake.analyze.residual.}\bfcode{residual\_gevp}}{\emph{A}, \emph{B}, \emph{la}, \emph{evec}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{A} -- left matrix

\item {} 
\textbf{B} -- right matrix

\item {} 
\textbf{la} -- eigenvalues

\item {} 
\textbf{evec} -- eigenvectors

\end{itemize}

\item[{Returns}] \leavevmode
res - residual

\end{description}\end{quote}

\end{fulllineitems}

\index{residual\_qevp() (in module brake.analyze.residual)}

\begin{fulllineitems}
\phantomsection\label{index:brake.analyze.residual.residual_qevp}\pysiglinewithargsret{\code{brake.analyze.residual.}\bfcode{residual\_qevp}}{\emph{M}, \emph{C}, \emph{K}, \emph{la}, \emph{evec}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{M} -- Mass Matrix

\item {} 
\textbf{C} -- Damping Matrix

\item {} 
\textbf{K} -- Stiffness Matrix

\item {} 
\textbf{la} -- eigenvalues

\item {} 
\textbf{evec} -- eigenvectors

\end{itemize}

\item[{Returns}] \leavevmode
res - residual

\end{description}\end{quote}

\end{fulllineitems}



\strong{See Also:}


\href{http://docs.scipy.org/doc/scipy-dev/reference/generated/scipy.sparse.linalg.onenormest.html}{scipy.sparse.linalg.onenormest}

\href{http://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.norm.html}{numpy.linalg.norm}




\section{visual}
\label{index:visual}
\href{https://bitbucket.org/akadar/brakesqueal0.1/src/master/brake/analyze/visual.py?at=master}{Source}
\phantomsection\label{index:module-brake.analyze.visual}\index{brake.analyze.visual (module)}
This module defines the following functions:

\begin{Verbatim}[commandchars=\\\{\}]
- plot\_eigs\_cover:

  plots all the eigenvalues (critical in red and normal in green) and the disc covering all the 
  eigenvalues. The output is generated as 'plotcover.png' in the output directory(with path 
  provided as input in the variable output\_path).

- plot\_eigs\_transition

  plots the eigenvalues very close to the imaginary axis, thus showing the transition of the 
  eigenvalues from the stable to the critical region of the target rectangle. The output is 
  generated as 'plottransition.png' in the output directory(with path provided as input in the 
  variable output\_path).
\end{Verbatim}
\index{plot\_eigs\_cover() (in module brake.analyze.visual)}

\begin{fulllineitems}
\phantomsection\label{index:brake.analyze.visual.plot_eigs_cover}\pysiglinewithargsret{\code{brake.analyze.visual.}\bfcode{plot\_eigs\_cover}}{\emph{obj}, \emph{la}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{obj} -- object of the class \code{BrakeClass}

\item {} 
\textbf{la} -- eigenavlues

\end{itemize}

\item[{Returns}] \leavevmode
radius of the disc covering all the eigenvalues

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_eigs\_transition() (in module brake.analyze.visual)}

\begin{fulllineitems}
\phantomsection\label{index:brake.analyze.visual.plot_eigs_transition}\pysiglinewithargsret{\code{brake.analyze.visual.}\bfcode{plot\_eigs\_transition}}{\emph{obj}, \emph{la}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{obj} -- object of the class \code{BrakeClass}

\item {} 
\textbf{la} -- eigenavlues

\end{itemize}

\item[{Returns}] \leavevmode
radius of the disc covering all the eigenvalues

\end{description}\end{quote}

\end{fulllineitems}



\strong{See Also:}

\begin{description}
\item[{\href{http://matplotlib.org/api/pyplot\_api.html}{matplotlib.pyplot}}] \leavevmode
Documentation of the Python Matplotlib library

\end{description}




\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{b}
\item {\texttt{brake.\_\_init\_\_}}, \pageref{index:module-brake.__init__}
\item {\texttt{brake.analyze.residual}}, \pageref{index:module-brake.analyze.residual}
\item {\texttt{brake.analyze.visual}}, \pageref{index:module-brake.analyze.visual}
\item {\texttt{brake.initialize.assemble}}, \pageref{index:module-brake.initialize.assemble}
\item {\texttt{brake.initialize.diagscale}}, \pageref{index:module-brake.initialize.diagscale}
\item {\texttt{brake.initialize.load}}, \pageref{index:module-brake.initialize.load}
\item {\texttt{brake.initialize.logger}}, \pageref{index:module-brake.initialize.logger}
\item {\texttt{brake.initialize.scale}}, \pageref{index:module-brake.initialize.scale}
\item {\texttt{brake.initialize.shift}}, \pageref{index:module-brake.initialize.shift}
\item {\texttt{brake.initialize.unlinearize}}, \pageref{index:module-brake.initialize.unlinearize}
\item {\texttt{brake.solve.cover}}, \pageref{index:module-brake.solve.cover}
\item {\texttt{brake.solve.projection}}, \pageref{index:module-brake.solve.projection}
\item {\texttt{brake.solve.qevp}}, \pageref{index:module-brake.solve.qevp}
\item {\texttt{brake.solve.solver}}, \pageref{index:module-brake.solve.solver}
\item {\texttt{brake.solve.traditionalProjection}}, \pageref{index:module-brake.solve.traditionalProjection}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
